冒泡排序是通过一系列的交换动作来完成的。代码如下：

 ``` 
 void BubbleSort(int a[],int n){
	int falg=0;
	for(int i=n-1;i>=1;i++){
		
		for(j=1;j<=i;j++){
			if(a[j]<a[j-1]){
				temp=a[j-1];
				a[j-1]=a[j];
				a[j]=temp;
				flag=1;
			}
			if(flag==0){//如果遍历后并未进行操作，说明此时的数组已经是有序的，则停止后边的操作。以减少时间的开支。 
				return ;
			}
		}
	}
}
```
分析其时间复杂度：当其是最坏的情况是，也就是整个数组都是逆序，那么整个执行的操作就是：n-1+n-2+n-3.....+1,即n(n-1)，即时间复杂度是O（n*n），当是最好的情况时，也就是数组是有序的其时间复杂度是 O（1).

综上，其时间复杂度是O（n*n）。

附加扩展：

关于双向冒泡排序， 顾名思义，双向冒泡排序是建立在冒泡排序的基础上，即增加了交替方向扫描的操作。具体代码如下：
 ```
void doublesort(int R[],int left ,int right){
	bool falg=true;
	while(flag){
		flag=false;
		for(int i=left;i<=right-1;i++){
			
			if(R[i]>R[i+1]){
				swap(R,i,i+1);//直接调用swap函数，进行交换。此循环是将大数沉底 
				flag=true;
			}			
			
		}
		right--;
		flag=false;
		for(int i=right;i<=left+1;i--){
			if(R[i]<R[i-1]){
				swap(R,i,i-1);//调用swap函数，将小数上升。 
				flag=true;
			}
		}
		left++;
	}	
}
  ```
 所谓双向冒泡排序就是利用两个循环将此序列的两头慢慢变得有序，即从左至右的话，大数不断下沉。从右至左，小数不断上升。如果一次遍历后，没有进行交换的操作，那么排序就是完成了。注意一点的是结束条件的确定，不仔细想的话，很可能把right==left作为结束的条件，这样是不对的，因为冒泡排序是与原始序列的是否是高度有序有着很大的关系。如果原始序列是高度有序的，那么冒泡排序可能一趟就结束了。这点不要和快排搞混。

 
